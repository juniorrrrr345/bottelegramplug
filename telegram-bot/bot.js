require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const fs = require('fs-extra');
const path = require('path');
const { loadConfig, saveConfig, getImagePath, IMAGES_DIR } = require('./config');
const { getMainKeyboard, getAdminKeyboard, getSocialManageKeyboard, getConfirmKeyboard } = require('./keyboards');

// V√©rifier les variables d'environnement
if (!process.env.BOT_TOKEN) {
    console.error('‚ùå BOT_TOKEN n\'est pas d√©fini dans le fichier .env');
    process.exit(1);
}

if (!process.env.ADMIN_ID) {
    console.error('‚ùå ADMIN_ID n\'est pas d√©fini dans le fichier .env');
    process.exit(1);
}

// Initialiser le bot
const bot = new TelegramBot(process.env.BOT_TOKEN, { polling: true });
const ADMIN_ID = parseInt(process.env.ADMIN_ID);

// √âtat des utilisateurs (pour g√©rer les conversations)
const userStates = {};
// Stocker les IDs des derniers messages pour chaque utilisateur
const lastMessages = {};
// Stocker les utilisateurs qui ont interagi avec le bot
const users = new Set();

// Charger la configuration au d√©marrage
let config = loadConfig();

// Charger les utilisateurs sauvegard√©s
const USERS_FILE = path.join(__dirname, 'users.json');
function loadUsers() {
    try {
        if (fs.existsSync(USERS_FILE)) {
            const data = fs.readJsonSync(USERS_FILE);
            data.forEach(userId => users.add(userId));
        }
    } catch (error) {
        console.error('Erreur lors du chargement des utilisateurs:', error);
    }
}

function saveUsers() {
    try {
        fs.writeJsonSync(USERS_FILE, Array.from(users));
    } catch (error) {
        console.error('Erreur lors de la sauvegarde des utilisateurs:', error);
    }
}

loadUsers();

// Fonction pour supprimer le dernier message d'un utilisateur
async function deleteLastMessage(chatId) {
    if (lastMessages[chatId]) {
        try {
            await bot.deleteMessage(chatId, lastMessages[chatId]);
        } catch (error) {
            // Ignorer l'erreur si le message est d√©j√† supprim√©
        }
        delete lastMessages[chatId];
    }
}

// Fonction pour envoyer un message et stocker son ID
async function sendMessageAndStore(chatId, text, options = {}) {
    await deleteLastMessage(chatId);
    const message = await bot.sendMessage(chatId, text, options);
    lastMessages[chatId] = message.message_id;
    return message;
}

// Fonction pour envoyer une photo et stocker son ID
async function sendPhotoAndStore(chatId, photo, options = {}) {
    await deleteLastMessage(chatId);
    const message = await bot.sendPhoto(chatId, photo, options);
    lastMessages[chatId] = message.message_id;
    return message;
}

// Fonction pour √©diter un message
async function editMessageAndStore(chatId, messageId, text, options = {}) {
    try {
        await bot.editMessageText(text, {
            chat_id: chatId,
            message_id: messageId,
            ...options
        });
        lastMessages[chatId] = messageId;
    } catch (error) {
        // Si l'√©dition √©choue, envoyer un nouveau message
        await sendMessageAndStore(chatId, text, options);
    }
}

// Fonction pour envoyer le message d'accueil
async function sendWelcomeMessage(chatId, messageId = null) {
    try {
        const options = {
            reply_markup: getMainKeyboard(config),
            parse_mode: 'HTML'
        };

        if (config.welcomeImage) {
            const imagePath = getImagePath(config.welcomeImage);
            if (fs.existsSync(imagePath)) {
                if (messageId) {
                    await deleteLastMessage(chatId);
                }
                await sendPhotoAndStore(chatId, imagePath, {
                    caption: config.welcomeMessage,
                    ...options
                });
            } else {
                if (messageId) {
                    await editMessageAndStore(chatId, messageId, config.welcomeMessage, options);
                } else {
                    await sendMessageAndStore(chatId, config.welcomeMessage, options);
                }
            }
        } else {
            if (messageId) {
                await editMessageAndStore(chatId, messageId, config.welcomeMessage, options);
            } else {
                await sendMessageAndStore(chatId, config.welcomeMessage, options);
            }
        }
    } catch (error) {
        console.error('Erreur lors de l\'envoi du message d\'accueil:', error);
        await sendMessageAndStore(chatId, '‚ùå Une erreur s\'est produite. Veuillez r√©essayer.');
    }
}

// Commande /start
bot.onText(/\/start/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    
    // Ajouter l'utilisateur √† la liste
    users.add(userId);
    saveUsers();
    
    // Supprimer le message de commande
    try {
        await bot.deleteMessage(chatId, msg.message_id);
    } catch (error) {}
    
    await sendWelcomeMessage(chatId);
});

// Commande /admin
bot.onText(/\/admin/, async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;

    // Supprimer le message de commande
    try {
        await bot.deleteMessage(chatId, msg.message_id);
    } catch (error) {}

    if (userId !== ADMIN_ID) {
        await sendMessageAndStore(chatId, '‚ùå Vous n\'√™tes pas autoris√© √† acc√©der au menu administrateur.');
        return;
    }

    await sendMessageAndStore(chatId, 'üîß Menu Administrateur', {
        reply_markup: getAdminKeyboard()
    });
});

// Gestion des callbacks
bot.on('callback_query', async (callbackQuery) => {
    const chatId = callbackQuery.message.chat.id;
    const messageId = callbackQuery.message.message_id;
    const userId = callbackQuery.from.id;
    const data = callbackQuery.data;

    // R√©pondre au callback pour √©viter le spinner
    await bot.answerCallbackQuery(callbackQuery.id);

    // V√©rifier les permissions admin pour les actions admin
    if (data.startsWith('admin_') && userId !== ADMIN_ID) {
        await bot.sendMessage(chatId, '‚ùå Vous n\'√™tes pas autoris√© √† effectuer cette action.');
        return;
    }

    try {
        switch (data) {
            case 'info':
                // Afficher les informations
                const infoOptions = {
                    parse_mode: 'HTML',
                    reply_markup: {
                        inline_keyboard: [[
                            { text: '‚¨ÖÔ∏è Retour', callback_data: 'back_to_main' }
                        ]]
                    }
                };
                
                if (config.welcomeImage) {
                    const imagePath = getImagePath(config.welcomeImage);
                    if (fs.existsSync(imagePath)) {
                        await bot.deleteMessage(chatId, messageId);
                        await sendPhotoAndStore(chatId, imagePath, {
                            caption: config.infoText,
                            ...infoOptions
                        });
                    } else {
                        await editMessageAndStore(chatId, messageId, config.infoText, infoOptions);
                    }
                } else {
                    await editMessageAndStore(chatId, messageId, config.infoText, infoOptions);
                }
                break;

            case 'back_to_main':
                await sendWelcomeMessage(chatId, messageId);
                break;

            case 'admin_menu':
                await editMessageAndStore(chatId, messageId, 'üîß Menu Administrateur', {
                    reply_markup: getAdminKeyboard()
                });
                break;

            case 'admin_edit_welcome':
                userStates[userId] = { action: 'editing_welcome', messageId: messageId };
                await editMessageAndStore(chatId, messageId, 'üìù Envoyez le nouveau message d\'accueil:', {
                    reply_markup: {
                        inline_keyboard: [[
                            { text: '‚ùå Annuler', callback_data: 'admin_menu' }
                        ]]
                    }
                });
                break;

            case 'admin_edit_photo':
                userStates[userId] = { action: 'editing_photo', messageId: messageId };
                await editMessageAndStore(chatId, messageId, 'üñºÔ∏è Envoyez la nouvelle photo d\'accueil:', {
                    reply_markup: {
                        inline_keyboard: [[
                            { text: '‚ùå Annuler', callback_data: 'admin_menu' }
                        ]]
                    }
                });
                break;

            case 'admin_edit_miniapp':
                userStates[userId] = { action: 'editing_miniapp_url', messageId: messageId };
                await editMessageAndStore(chatId, messageId, 'üì± Envoyez l\'URL de la mini application (ou "supprimer" pour la retirer):', {
                    reply_markup: {
                        inline_keyboard: [[
                            { text: '‚ùå Annuler', callback_data: 'admin_menu' }
                        ]]
                    }
                });
                break;

            case 'admin_manage_social':
                await editMessageAndStore(chatId, messageId, 'üåê Gestion des r√©seaux sociaux', {
                    reply_markup: getSocialManageKeyboard(config)
                });
                break;

            case 'admin_add_social':
                userStates[userId] = { action: 'adding_social_name', messageId: messageId };
                await editMessageAndStore(chatId, messageId, '‚ûï Entrez le nom du r√©seau social:', {
                    reply_markup: {
                        inline_keyboard: [[
                            { text: '‚ùå Annuler', callback_data: 'admin_manage_social' }
                        ]]
                    }
                });
                break;

            case 'admin_edit_info':
                userStates[userId] = { action: 'editing_info', messageId: messageId };
                await editMessageAndStore(chatId, messageId, '‚ÑπÔ∏è Envoyez le nouveau texte pour la section informations:', {
                    reply_markup: {
                        inline_keyboard: [[
                            { text: '‚ùå Annuler', callback_data: 'admin_menu' }
                        ]]
                    }
                });
                break;

            case 'admin_broadcast':
                userStates[userId] = { action: 'broadcast_message', messageId: messageId };
                await editMessageAndStore(chatId, messageId, 'üì¢ Envoyez le message √† diffuser √† tous les utilisateurs:', {
                    reply_markup: {
                        inline_keyboard: [[
                            { text: '‚ùå Annuler', callback_data: 'admin_menu' }
                        ]]
                    }
                });
                break;

            case 'admin_close':
                await bot.deleteMessage(chatId, messageId);
                delete lastMessages[chatId];
                break;

            case 'cancel':
                delete userStates[userId];
                await bot.sendMessage(chatId, '‚ùå Action annul√©e.');
                break;

            default:
                // Gestion de la suppression des r√©seaux sociaux
                if (data.startsWith('admin_delete_social_')) {
                    const index = parseInt(data.replace('admin_delete_social_', ''));
                    if (config.socialNetworks && config.socialNetworks[index]) {
                        config.socialNetworks.splice(index, 1);
                        saveConfig(config);
                        await bot.answerCallbackQuery(callbackQuery.id, {
                            text: '‚úÖ R√©seau social supprim√©!',
                            show_alert: true
                        });
                        await bot.editMessageReplyMarkup(getSocialManageKeyboard(config), {
                            chat_id: chatId,
                            message_id: messageId
                        });
                    }
                }
                break;
        }
    } catch (error) {
        console.error('Erreur lors du traitement du callback:', error);
        await bot.sendMessage(chatId, '‚ùå Une erreur s\'est produite. Veuillez r√©essayer.');
    }
});

// Gestion des messages texte
bot.on('message', async (msg) => {
    // Ignorer les commandes
    if (msg.text && msg.text.startsWith('/')) return;

    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const userState = userStates[userId];

    if (!userState) return;

    // Supprimer le message de l'utilisateur pour garder le chat propre
    try {
        await bot.deleteMessage(chatId, msg.message_id);
    } catch (error) {}

    try {
        switch (userState.action) {
            case 'editing_welcome':
                config.welcomeMessage = msg.text;
                saveConfig(config);
                delete userStates[userId];
                await editMessageAndStore(chatId, userState.messageId, '‚úÖ Message d\'accueil mis √† jour!', {
                    reply_markup: getAdminKeyboard()
                });
                break;

            case 'editing_info':
                config.infoText = msg.text;
                saveConfig(config);
                delete userStates[userId];
                await editMessageAndStore(chatId, userState.messageId, '‚úÖ Texte d\'informations mis √† jour!', {
                    reply_markup: getAdminKeyboard()
                });
                break;

            case 'editing_miniapp_url':
                if (msg.text.toLowerCase() === 'supprimer') {
                    config.miniApp.url = null;
                } else {
                    config.miniApp.url = msg.text;
                }
                userStates[userId] = { 
                    action: 'editing_miniapp_text', 
                    messageId: userState.messageId 
                };
                await editMessageAndStore(chatId, userState.messageId, 'üì± Entrez le texte du bouton pour la mini application:', {
                    reply_markup: {
                        inline_keyboard: [[
                            { text: '‚ùå Annuler', callback_data: 'admin_menu' }
                        ]]
                    }
                });
                break;

            case 'editing_miniapp_text':
                config.miniApp.text = msg.text;
                saveConfig(config);
                delete userStates[userId];
                await editMessageAndStore(chatId, userState.messageId, '‚úÖ Mini application mise √† jour!', {
                    reply_markup: getAdminKeyboard()
                });
                break;

            case 'adding_social_name':
                userStates[userId] = { 
                    action: 'adding_social_url',
                    socialName: msg.text,
                    messageId: userState.messageId
                };
                await editMessageAndStore(chatId, userState.messageId, 'üîó Entrez l\'URL du r√©seau social:', {
                    reply_markup: {
                        inline_keyboard: [[
                            { text: '‚ùå Annuler', callback_data: 'admin_manage_social' }
                        ]]
                    }
                });
                break;

            case 'adding_social_url':
                userStates[userId] = {
                    ...userState,
                    action: 'adding_social_emoji',
                    socialUrl: msg.text
                };
                await editMessageAndStore(chatId, userState.messageId, 'üòÄ Entrez un emoji pour ce r√©seau social (ou envoyez "skip" pour utiliser üîó):', {
                    reply_markup: {
                        inline_keyboard: [[
                            { text: '‚ùå Annuler', callback_data: 'admin_manage_social' }
                        ]]
                    }
                });
                break;

            case 'adding_social_emoji':
                const emoji = msg.text.toLowerCase() === 'skip' ? 'üîó' : msg.text;
                if (!config.socialNetworks) {
                    config.socialNetworks = [];
                }
                config.socialNetworks.push({
                    name: userState.socialName,
                    url: userState.socialUrl,
                    emoji: emoji
                });
                saveConfig(config);
                delete userStates[userId];
                await editMessageAndStore(chatId, userState.messageId, '‚úÖ R√©seau social ajout√©!', {
                    reply_markup: getSocialManageKeyboard(config)
                });
                break;

            case 'broadcast_message':
                const message = msg.text;
                let successCount = 0;
                let failCount = 0;
                
                await editMessageAndStore(chatId, userState.messageId, 'üì§ Envoi en cours...');
                
                for (const targetUserId of users) {
                    if (targetUserId !== userId) { // Ne pas envoyer √† l'admin
                        try {
                            await bot.sendMessage(targetUserId, `üì¢ Message de l'administrateur:\n\n${message}`);
                            successCount++;
                        } catch (error) {
                            failCount++;
                        }
                    }
                }
                
                delete userStates[userId];
                await editMessageAndStore(chatId, userState.messageId, 
                    `‚úÖ Message diffus√©!\n\nüìä Statistiques:\n‚úÖ Envoy√©s: ${successCount}\n‚ùå √âchecs: ${failCount}`, {
                    reply_markup: getAdminKeyboard()
                });
                break;
        }
    } catch (error) {
        console.error('Erreur lors du traitement du message:', error);
        await bot.sendMessage(chatId, '‚ùå Une erreur s\'est produite. Veuillez r√©essayer.');
    }
});

// Gestion des photos
bot.on('photo', async (msg) => {
    const chatId = msg.chat.id;
    const userId = msg.from.id;
    const userState = userStates[userId];

    if (!userState || userState.action !== 'editing_photo') return;

    // Supprimer le message de photo pour garder le chat propre
    try {
        await bot.deleteMessage(chatId, msg.message_id);
    } catch (error) {}

    try {
        // Obtenir la photo de meilleure qualit√©
        const photo = msg.photo[msg.photo.length - 1];
        const fileId = photo.file_id;

        // T√©l√©charger la photo
        const file = await bot.getFile(fileId);
        const filePath = file.file_path;
        const downloadUrl = `https://api.telegram.org/file/bot${process.env.BOT_TOKEN}/${filePath}`;

        // Sauvegarder la photo
        const fileName = `welcome_${Date.now()}.jpg`;
        const localPath = path.join(IMAGES_DIR, fileName);

        const https = require('https');
        const fileStream = fs.createWriteStream(localPath);

        https.get(downloadUrl, (response) => {
            response.pipe(fileStream);
            fileStream.on('finish', async () => {
                fileStream.close();
                
                // Supprimer l'ancienne photo si elle existe
                if (config.welcomeImage) {
                    const oldPath = getImagePath(config.welcomeImage);
                    if (fs.existsSync(oldPath)) {
                        fs.unlinkSync(oldPath);
                    }
                }

                // Mettre √† jour la configuration
                config.welcomeImage = fileName;
                saveConfig(config);
                delete userStates[userId];

                await editMessageAndStore(chatId, userState.messageId, '‚úÖ Photo d\'accueil mise √† jour!', {
                    reply_markup: getAdminKeyboard()
                });
            });
        });
    } catch (error) {
        console.error('Erreur lors du traitement de la photo:', error);
        await bot.sendMessage(chatId, '‚ùå Une erreur s\'est produite lors du traitement de la photo.');
    }
});

// Gestion des erreurs
bot.on('polling_error', (error) => {
    console.error('Erreur de polling:', error);
});

console.log('ü§ñ Bot d√©marr√© avec succ√®s!');
console.log(`üì± Parlez au bot: https://t.me/${process.env.BOT_USERNAME || 'votre_bot'}`);
console.log(`üîß ID Admin: ${ADMIN_ID}`);